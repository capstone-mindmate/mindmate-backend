<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebSocket 채팅 테스트</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; }
        .form-group input, .form-group textarea { width: 100%; padding: 8px; box-sizing: border-box; }
        button { padding: 8px 15px; margin-right: 10px; cursor: pointer; }
        #log { height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; margin-top: 20px; background-color: #f5f5f5; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        .warning { color: orange; }
        .flex-container { display: flex; justify-content: space-between; }
        .col { flex: 1; margin: 0 10px; }
        .message-container { border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 5px; }
        .message-sender { font-weight: bold; }
        .message-time { font-size: 0.8em; color: #666; }
        .message-content { margin-top: 5px; }
        .read-status { font-size: 0.8em; color: #666; text-align: right; }
        .online-status { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .online { background-color: green; }
        .offline { background-color: gray; }
        .reaction-container { display: flex; margin-top: 5px; }
        .reaction-button { margin-right: 5px; cursor: pointer; padding: 2px 5px; border-radius: 3px; background-color: #f0f0f0; }
        .reaction-button.active { background-color: #d1e7ff; }
        .reaction-count { margin-left: 3px; font-size: 0.8em; }
        .custom-form { background-color: #f5f5f5; padding: 10px; border-radius: 5px; margin-top: 10px; }
        .custom-form-header { font-weight: bold; margin-bottom: 5px; }
        .custom-form-question { margin-bottom: 5px; }
        .custom-form-answer { margin-left: 15px; color: #0066cc; }
        .custom-form-input { width: 100%; padding: 5px; margin-bottom: 5px; }
    </style>
</head>
<body>
<div class="container">
    <h1>WebSocket 채팅 테스트</h1>
    
    <div class="flex-container">
        <div class="col">
            <div class="form-group">
                <label for="token">JWT 토큰:</label>
                <input type="text" id="token" placeholder="JWT 토큰" value="여기에 JWT 토큰 입력">
            </div>
            
            <div>
                <button onclick="connect()">연결</button>
                <button onclick="disconnect()">연결 해제</button>
            </div>
            
            <div class="form-group" style="margin-top: 20px;">
                <label for="roomId">채팅방 ID:</label>
                <input type="text" id="roomId" placeholder="채팅방 ID" value="1">
                <button onclick="subscribe()">채팅방 입장</button>
                <button onclick="unsubscribe()">채팅방 퇴장</button>
            </div>
            
            <div class="form-group">
                <label for="message">메시지:</label>
                <textarea id="message" placeholder="보낼 메시지를 입력하세요" rows="3"></textarea>
                <button onclick="sendMessage()">전송</button>
            </div>
            
            <div class="form-group">
                <button onclick="markAsRead()">읽음 처리</button>
                <button onclick="fetchMessages()">메시지 조회 (REST)</button>
                <button onclick="fetchChatRooms()">채팅방 목록 조회</button>
                <button onclick="showCustomFormCreator()">커스텀폼 생성</button>
            </div>
            
            <!-- 커스텀폼 생성 UI -->
            <div id="customFormCreator" style="display:none; margin-top: 15px; border: 1px solid #ccc; padding: 10px; border-radius: 5px;">
                <h3>커스텀폼 생성</h3>
                <div id="questionContainer">
                    <div class="form-group">
                        <input type="text" class="custom-form-input" placeholder="질문 1">
                    </div>
                </div>
                <button onclick="addQuestion()">질문 추가</button>
                <button onclick="createCustomForm()">폼 생성</button>
                <button onclick="cancelCustomForm()">취소</button>
            </div>
        </div>
        
        <div class="col">
            <h3>채팅방 정보</h3>
            <div id="roomInfo">
                <p>채팅방: <span id="currentRoomDisplay">없음</span></p>
                <p>참가자 상태:</p>
                <ul id="participantStatus">
                    <li>참가자 정보가 없습니다.</li>
                </ul>
                <p>읽지 않은 메시지: <span id="unreadCount">0</span></p>
            </div>
            
            <h3>메시지</h3>
            <div id="messages"></div>
        </div>
    </div>
    
    <h3>로그</h3>
    <div id="log"></div>
</div>

<script>
    let stompClient = null;
    let currentRoomId = null;
    let subscriptions = {};
    let userId = null;
    let messages = [];
    let participants = {};
    let baseUrl = 'http://localhost:8080';
    let heartbeatInterval;

    // 감정표현 이모지 매핑
    const reactionEmojis = {
        'LIKE': '👍',
        'HEART': '❤️',
        'LAUGH': '😂',
        'SAD': '😢',
        'ANGRY': '😡'
    };

    function connect() {
        const token = document.getElementById('token').value;
        if (!token) {
            logMessage("토큰을 입력해주세요", "error");
            return;
        }

        const socket = new SockJS(baseUrl + '/ws');
        stompClient = Stomp.over(socket);
        stompClient.debug = null;
        
        logMessage("연결 시도 중...", "info");
        stompClient.connect(
            { 'Authorization': 'Bearer ' + token },
            function(frame) {
                logMessage('연결 성공: ' + frame, "success");
                
                try {
                    const base64Url = token.split('.')[1];
                    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                    }).join(''));
                    const payload = JSON.parse(jsonPayload);
                    userId = payload.userId || payload.sub;
                    logMessage(`사용자 ID: ${userId}`, "info");
                } catch (e) {
                    logMessage('토큰에서 사용자 ID를 추출할 수 없습니다: ' + e, "warning");
                }
                
                subscriptions['notification'] = stompClient.subscribe('/user/queue/notification', handleNotification);
                subscriptions['unread'] = stompClient.subscribe('/user/queue/unread', updateUnreadCount);
                
                updatePresence('ONLINE');
                startHeartbeat();
            },
            function(error) {
                logMessage('연결 오류: ' + error, "error");
            }
        );
    }

    function disconnect() {
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        if (stompClient !== null) {
            updatePresence('OFFLINE');
            Object.values(subscriptions).forEach(sub => {
                try {
                    sub.unsubscribe();
                } catch (e) {}
            });
            subscriptions = {};
            
            stompClient.disconnect();
            logMessage('연결이 해제되었습니다', "info");
            stompClient = null;
            currentRoomId = null;
            updateRoomDisplay();
        }
    }

    function subscribe() {
        if (!stompClient) {
            logMessage("먼저 연결을 해주세요", "error");
            return;
        }
        
        if (currentRoomId) {
            unsubscribeRoom(currentRoomId);
        }
        
        currentRoomId = document.getElementById('roomId').value;
        
        logMessage(`채팅방 ${currentRoomId} 구독 중...`, "info");
        
        subscriptions[`room_${currentRoomId}`] = stompClient.subscribe(
            '/topic/chat.room.' + currentRoomId,
            handleIncomingMessage
        );

        subscriptions[`read_${currentRoomId}`] = stompClient.subscribe(
            '/topic/chat.room.' + currentRoomId + '.read',
            updateReadStatus
        );
        
        // 감정표현 구독 추가
        subscriptions[`reaction_${currentRoomId}`] = stompClient.subscribe(
            '/topic/chat.room.' + currentRoomId + '.reaction',
            handleReaction
        );
        
        // 커스텀폼 구독 추가
        subscriptions[`customform_${currentRoomId}`] = stompClient.subscribe(
            '/topic/chat.room.' + currentRoomId + '.customform',
            handleCustomForm
        );

        updatePresence('ONLINE', currentRoomId);
        markAsRead();
        fetchMessages();
        updateRoomDisplay();
        logMessage(`채팅방 ${currentRoomId} 구독 완료`, "success");
    }

    function unsubscribe() {
        if (!currentRoomId) {
            logMessage("현재 구독 중인 채팅방이 없습니다", "warning");
            return;
        }
        
        unsubscribeRoom(currentRoomId);
        updatePresence('ONLINE', null);
        currentRoomId = null;
        updateRoomDisplay();
        document.getElementById('messages').innerHTML = '';
        logMessage("채팅방에서 퇴장했습니다", "info");
    }

    function unsubscribeRoom(roomId) {
        ['room', 'read', 'reaction', 'customform'].forEach(type => {
            const subKey = `${type}_${roomId}`;
            if (subscriptions[subKey]) {
                try {
                    subscriptions[subKey].unsubscribe();
                    delete subscriptions[subKey];
                } catch (e) {
                    logMessage(`구독 해제 오류 (${type}): ${e}`, "error");
                }
            }
        });
    }

    function sendMessage() {
        if (!stompClient || !currentRoomId) {
            logMessage("먼저 채팅방에 입장해주세요", "error");
            return;
        }
        
        const messageContent = document.getElementById('message').value;
        if (!messageContent) {
            logMessage("메시지를 입력해주세요", "error");
            return;
        }
        
        const chatMessage = {
            roomId: currentRoomId,
            content: messageContent,
            type: 'TEXT'
        };
        
        logMessage(`메시지 전송 중: ${JSON.stringify(chatMessage)}`, "info");
        stompClient.send('/app/chat.send', {}, JSON.stringify(chatMessage));
        
        document.getElementById('message').value = '';
    }

    function markAsRead() {
        if (!stompClient || !currentRoomId) {
            logMessage("채팅방에 입장한 상태에서만 읽음 처리가 가능합니다", "warning");
            return;
        }
        
        const readRequest = { roomId: currentRoomId };
        stompClient.send('/app/chat.read', {}, JSON.stringify(readRequest));
        logMessage(`채팅방 ${currentRoomId}의 메시지를 읽음 처리했습니다`, "info");
    }

    function fetchMessages() {
        if (!currentRoomId) {
            logMessage("먼저 채팅방을 선택해주세요", "warning");
            return;
        }
        
        const token = document.getElementById('token').value;
        if (!token) {
            logMessage("토큰을 입력해주세요", "error");
            return;
        }
        
        logMessage(`채팅방 ${currentRoomId}의 메시지를 조회합니다...`, "info");
        
        fetch(`${baseUrl}/api/chat/rooms/${currentRoomId}/messages?page=0&size=20`, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) throw new Error('메시지 조회 실패: ' + response.status);
            return response.json();
        })
        .then(data => {
            logMessage(`메시지 조회 성공: ${data.messages.length}개의 메시지`, "success");
            displayMessages(data);
            updateParticipantStatus(data);
        })
        .catch(error => logMessage('메시지 조회 오류: ' + error.message, "error"));
    }

    function fetchChatRooms() {
        const token = document.getElementById('token').value;
        if (!token) {
            logMessage("토큰을 입력해주세요", "error");
            return;
        }
        
        logMessage("채팅방 목록을 조회합니다...", "info");
        
        fetch(`${baseUrl}/api/chat/rooms?page=0&size=10`, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) throw new Error('채팅방 목록 조회 실패: ' + response.status);
            return response.json();
        })
        .then(data => {
            logMessage(`채팅방 목록 조회 성공: ${data.content.length}개의 채팅방`, "success");
            displayChatRooms(data);
        })
        .catch(error => logMessage('채팅방 목록 조회 오류: ' + error.message, "error"));
    }

    function handleIncomingMessage(message) {
        let messageData;
        try {
            messageData = JSON.parse(message.body);
            console.log("Received message:", messageData);
            
            if (messageData.filtered) {
                // 필터링된 메시지 처리
                logMessage(`메시지가 필터링되었습니다: ${messageData.content}`, "warning");
                addMessageToDisplay({
                    id: messageData.id || 'filtered-' + new Date().getTime(),
                    roomId: messageData.roomId,
                    senderId: messageData.senderId,
                    senderName: messageData.senderName,
                    content: messageData.content,
                    createdAt: messageData.createdAt,
                    type: 'FILTERED'
                });
            } else if (messageData.error) {
                // 오류 메시지 처리
                logMessage(`메시지 전송 오류: ${messageData.errorMessage}`, "error");
            } else {
                // 일반 메시지 처리
                addMessageToDisplay(messageData);
            }
        } catch (e) {
            console.error("Error processing message:", e, message.body);
        }
    }

    // 알림 처리
    function handleNotification(notification) {
        // 알림 타입에 따른 처리
        if (notification.type === 'NEW_MESSAGE') {
            // 새 메시지 알림
            logMessage(`새 메시지 알림: 채팅방 ${notification.roomId}에 새 메시지가 있습니다`, "info");
        } else if (notification.type === 'ROOM_STATUS') {
            // 채팅방 상태 변경 알림
            logMessage(`채팅방 상태 변경: 채팅방 ${notification.roomId}의 상태가 ${notification.status}로 변경되었습니다`, "info");
        }
    }
    
    function updatePresence(status, activeRoomId = currentRoomId) {
        if (stompClient && stompClient.connected) {
            stompClient.send('/app/presence', {},
                JSON.stringify({
                    status: status,
                    activeRoomId: activeRoomId
                })
            );
            logMessage(`사용자 상태가 ${status}로 변경되었습니다.`, "info");
        }
    }

    function updateUnreadCount(message) {
        const unreadData = JSON.parse(message.body);
        const roomId = unreadData.roomId;
        const count = unreadData.unreadCount;
        
        if (roomId === currentRoomId) {
            document.getElementById('unreadCount').textContent = count;
        }
        
        logMessage(`채팅방 ${roomId}의 읽지 않은 메시지: ${count}개`, "info");
    }
    
    function updateUnreadCount(message) {
        const unreadData = JSON.parse(message.body);
        const roomId = unreadData.roomId;
        const count = unreadData.unreadCount;
        
        if (roomId === currentRoomId) {
            document.getElementById('unreadCount').textContent = count;
        }
        
        logMessage(`채팅방 ${roomId}의 읽지 않은 메시지: ${count}개`, "info");
    }
    
    function updateReadStatus(message) {
        const readData = JSON.parse(message.body);
        logMessage(`사용자 ${readData.userId}가 채팅방 ${readData.roomId}의 메시지를 읽었습니다`, "info");
        
        // 읽음 상태 UI 업데이트
        document.querySelectorAll('.message-container').forEach(el => {
            if (el.dataset.roomId === readData.roomId) {
                const readStatus = el.querySelector('.read-status');
                if (readStatus) {
                    readStatus.textContent = '읽음';
                }
            }
        });
    }
    
    // 감정표현 처리
    function handleReaction(message) {
        const reactionData = JSON.parse(message.body);
        logMessage(`메시지 ${reactionData.messageId}에 ${reactionData.reactionType} 감정표현이 추가/변경되었습니다`, "info");
        
        // 메시지 목록 새로고침
        fetchMessages();
    }
    
    // 커스텀폼 처리
    function handleCustomForm(message) {
        const formData = JSON.parse(message.body);
        logMessage(`커스텀폼 ${formData.id} 업데이트: ${formData.isAnswered ? '응답됨' : '생성됨'}`, "info");
        
        // 메시지 목록 새로고침
        fetchMessages();
    }
    
    function displayMessages(data) {
        messages = data.messages || [];
        const messagesContainer = document.getElementById('messages');
        messagesContainer.innerHTML = '';
        
        messages.forEach(message => {
            addMessageToDisplay(message, false);
        });
        
        // 스크롤을 가장 아래로
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    function addMessageToDisplay(message, isNew = true) {
        const messagesContainer = document.getElementById('messages');
        const messageElement = document.createElement('div');
        messageElement.className = 'message-container';
        messageElement.dataset.messageId = message.id;
        messageElement.dataset.roomId = currentRoomId;
        
        const isMyMessage = message.senderId === userId;
        
        let messageContent = `
            <div class="message-header">
                <span class="message-sender">${message.senderName}</span>
                <span class="message-time">${formatTime(message.createdAt)}</span>
            </div>
            <div class="message-content">${message.content}</div>
        `;
        
        // 커스텀폼 표시
        console.log('message: ', message);
        if (message.type === 'CUSTOM_FORM' && message.customForm) {
            const form = message.customForm;
            let formHtml = `
                <div class="custom-form" data-form-id="${form.id}">
                    <div class="custom-form-header">커스텀폼 ${form.isAnswered ? '(응답됨)' : ''}</div>
            `;
            
            form.items.forEach((item, index) => {
                formHtml += `<div class="custom-form-question">${item.question}</div>`;
                
            if (form.answered  && item.answer) {
                formHtml += `<div class="custom-form-answer">${item.answer}</div>`;
            } else if (!form.isAnswered) {
                // userId가 숫자로 저장되어 있지만 form.responderId가 문자열로 전달될 수 있음
                if (form.responderId == userId) { // 느슨한 비교 사용
                    formHtml += `<input type="text" class="custom-form-input" data-question-id="${item.id || index}" placeholder="답변을 입력하세요">`;
                } else {
                    formHtml += `<div class="custom-form-pending">응답 대기 중...</div>`;
                }
            }

            });
            
            if (!form.answered  && form.responderId == userId) {
                formHtml += `<button onclick="respondToForm(${form.id})">응답 제출</button>`;
            }
            
            formHtml += `</div>`;
            messageContent += formHtml;
        }

        
        // 감정표현 버튼 추가
        messageContent += `<div class="reaction-container">`;
        
        Object.entries(reactionEmojis).forEach(([type, emoji]) => {
            const count = message.reactionCounts && message.reactionCounts[type] ? message.reactionCounts[type] : 0;
            const isActive = message.userReaction === type;
            
            messageContent += `
                <span class="reaction-button ${isActive ? 'active' : ''}"
                      onclick="addReaction('${message.id}', '${type}')">
                    ${emoji} <span class="reaction-count">${count > 0 ? count : ''}</span>
                </span>
            `;
        });
        
        messageContent += `</div>`;
        
        // 읽음 상태 표시
        messageContent += `<div class="read-status">${isMyMessage ? '전송됨' : ''}</div>`;
        
        messageElement.innerHTML = messageContent;
        
        if (isNew) {
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        } else {
            messagesContainer.appendChild(messageElement);
        }
    }
    
    function addReaction(messageId, reactionType) {
        if (!stompClient || !currentRoomId) {
            logMessage("먼저 채팅방에 입장해주세요", "error");
            return;
        }
        
        const reactionRequest = {
            messageId: messageId,
            roomId: currentRoomId,
            reactionType: reactionType
        };
        
        stompClient.send('/app/chat.reaction', {}, JSON.stringify(reactionRequest));
        logMessage(`메시지 ${messageId}에 ${reactionType} 감정표현을 추가합니다`, "info");
    }
    
    function showCustomFormCreator() {
        if (!currentRoomId) {
            logMessage("먼저 채팅방에 입장해주세요", "error");
            return;
        }
        
        document.getElementById('customFormCreator').style.display = 'block';
    }
    
    function addQuestion() {
        const container = document.getElementById('questionContainer');
        const questionCount = container.children.length + 1;
        
        const questionDiv = document.createElement('div');
        questionDiv.className = 'form-group';
        questionDiv.innerHTML = `<input type="text" class="custom-form-input" placeholder="질문 ${questionCount}">`;
        
        container.appendChild(questionDiv);
    }
    
    function createCustomForm() {
        if (!stompClient || !currentRoomId) {
            logMessage("먼저 채팅방에 입장해주세요", "error");
            return;
        }
        
        const questions = [];
        document.querySelectorAll('#questionContainer input').forEach(input => {
            if (input.value.trim()) {
                questions.push(input.value.trim());
            }
        });
        
        if (questions.length === 0) {
            logMessage("최소 하나 이상의 질문을 입력해주세요", "error");
            return;
        }
        
        const formRequest = {
            chatRoomId: currentRoomId,
            questions: questions
        };
        
        stompClient.send('/app/chat.customform.create', {}, JSON.stringify(formRequest));
        logMessage(`커스텀폼을 생성합니다: ${questions.length}개의 질문`, "info");
        
        cancelCustomForm();
    }
    
    function cancelCustomForm() {
        document.getElementById('customFormCreator').style.display = 'none';
        document.getElementById('questionContainer').innerHTML = `
            <div class="form-group">
                <input type="text" class="custom-form-input" placeholder="질문 1">
            </div>
        `;
    }
    
    function respondToForm(formId) {
        if (!stompClient || !currentRoomId) {
            logMessage("먼저 채팅방에 입장해주세요", "error");
            return;
        }
        
        const answers = [];
        // 특정 폼 ID에 해당하는 입력 필드만 선택하도록 수정
        document.querySelectorAll(`.custom-form[data-form-id="${formId}"] .custom-form-input`).forEach(input => {
            answers.push(input.value.trim() || "답변 없음");
        });
        
        if (answers.length === 0) {
            logMessage("답변을 입력해주세요", "error");
            return;
        }
        
        const responseRequest = {
            formId: formId,
            chatRoomId: currentRoomId,
            answers: answers
        };
        
        stompClient.send('/app/chat.customform.respond', {}, JSON.stringify(responseRequest));
        logMessage(`커스텀폼 ${formId}에 응답합니다`, "info");
    }



    
    function updateParticipantStatus(data) {
        if (!data.participants) return;
        
        participants = data.participants || {};
        const statusList = document.getElementById('participantStatus');
        statusList.innerHTML = '';
        
        Object.entries(participants).forEach(([participantId, participant]) => {
            const li = document.createElement('li');
            const isOnline = participant.online;
            
            li.innerHTML = `
                <span class="online-status ${isOnline ? 'online' : 'offline'}"></span>
                ${participant.name} (${isOnline ? '온라인' : '오프라인'})
            `;
            
            statusList.appendChild(li);
        });
    }
    
    function updateRoomDisplay() {
        document.getElementById('currentRoomDisplay').textContent = currentRoomId || '없음';
    }
    
    function displayChatRooms(data) {
        const rooms = data.content || [];
        let html = '<h3>채팅방 목록</h3><ul>';
        
        rooms.forEach(room => {
            html += `<li>
                <strong>${room.roomName || '채팅방 ' + room.id}</strong>
                (ID: ${room.id}, 상태: ${room.status})
                <button onclick="enterRoom(${room.id})">입장</button>
            </li>`;
        });
        
        html += '</ul>';
        
        const logDiv = document.getElementById('log');
        logDiv.innerHTML += html;
        logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    function enterRoom(roomId) {
        document.getElementById('roomId').value = roomId;
        subscribe();
    }
    
    function formatTime(timestamp) {
        if (!timestamp) return '';
        
        const date = new Date(timestamp);
        return date.toLocaleString();
    }
    
    function logMessage(message, type = "info") {
        const logDiv = document.getElementById('log');
        const messageElement = document.createElement('div');
        messageElement.className = type;
        messageElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        
        logDiv.appendChild(messageElement);
        logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    function startHeartbeat() {
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        
        heartbeatInterval = setInterval(() => {
            if (stompClient && stompClient.connected) {
                updatePresence(currentRoomId ? 'ONLINE' : 'ONLINE', currentRoomId);
            } else {
                clearInterval(heartbeatInterval);
            }
        }, 30000); // 30초마다 상태 업데이트
    }
    
    // 페이지 가시성 변경 감지
    document.addEventListener('visibilitychange', function() {
        // AWAY 대신 OFFLINE 사용
        const status = document.hidden ? 'OFFLINE' : 'ONLINE';
        updatePresence(status);
        if (status === 'ONLINE' && currentRoomId) {
            markAsRead();
        }
    });
</script>
</body>
</html>


