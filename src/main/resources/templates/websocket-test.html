<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebSocket 채팅 테스트</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; }
        .form-group input, .form-group textarea { width: 100%; padding: 8px; box-sizing: border-box; }
        button { padding: 8px 15px; margin-right: 10px; cursor: pointer; }
        #log { height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; margin-top: 20px; background-color: #f5f5f5; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        .warning { color: orange; }
        .flex-container { display: flex; justify-content: space-between; }
        .col { flex: 1; margin: 0 10px; }
        .message-container { border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 5px; }
        .message-sender { font-weight: bold; }
        .message-time { font-size: 0.8em; color: #666; }
        .message-content { margin-top: 5px; }
        .read-status { font-size: 0.8em; color: #666; text-align: right; }
        .online-status { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .online { background-color: green; }
        .offline { background-color: gray; }
    </style>
</head>
<body>
<div class="container">
    <h1>WebSocket 채팅 테스트</h1>
    
    <div class="flex-container">
        <div class="col">
            <div class="form-group">
                <label for="token">JWT 토큰:</label>
                <input type="text" id="token" placeholder="JWT 토큰" value="여기에 JWT 토큰 입력">
            </div>
            
            <div>
                <button onclick="connect()">연결</button>
                <button onclick="disconnect()">연결 해제</button>
            </div>
            
            <div class="form-group" style="margin-top: 20px;">
                <label for="roomId">채팅방 ID:</label>
                <input type="text" id="roomId" placeholder="채팅방 ID" value="1">
                <button onclick="subscribe()">채팅방 입장</button>
                <button onclick="unsubscribe()">채팅방 퇴장</button>
            </div>
            
            <div class="form-group">
                <label for="message">메시지:</label>
                <textarea id="message" placeholder="보낼 메시지를 입력하세요" rows="3"></textarea>
                <button onclick="sendMessage()">전송</button>
            </div>
            
            <div id="typingIndicator" style="display:none; font-style:italic; color:#666; margin-top:5px;"></div>
            
            <div class="form-group">
                <button onclick="markAsRead()">읽음 처리</button>
                <button onclick="fetchMessages()">메시지 조회 (REST)</button>
                <button onclick="fetchChatRooms()">채팅방 목록 조회</button>
            </div>
        </div>
        
        <div class="col">
            <h3>채팅방 정보</h3>
            <div id="roomInfo">
                <p>채팅방: <span id="currentRoomDisplay">없음</span></p>
                <p>참가자 상태:</p>
                <ul id="participantStatus">
                    <li>참가자 정보가 없습니다.</li>
                </ul>
                <p>읽지 않은 메시지: <span id="unreadCount">0</span></p>
            </div>
            
            <h3>메시지</h3>
            <div id="messages"></div>
        </div>
    </div>
    
    <h3>로그</h3>
    <div id="log"></div>
</div>

<script>
    let stompClient = null;
    let currentRoomId = null;
    let subscriptions = {};
    let userId = null;
    let messages = [];
    let participants = {};
    let baseUrl = 'http://localhost:8080';
    let typingTimeout = null;
    let heartbeatInterval;

    function connect() {
        const token = document.getElementById('token').value;
        if (!token) {
            logMessage("토큰을 입력해주세요", "error");
            return;
        }

        const socket = new SockJS(baseUrl + '/ws');
        stompClient = Stomp.over(socket);
        stompClient.debug = null;
        
        logMessage("연결 시도 중...", "info");
        stompClient.connect(
            { 'Authorization': 'Bearer ' + token },
            function(frame) {
                logMessage('연결 성공: ' + frame, "success");
                
                try {
                    const base64Url = token.split('.')[1];
                    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                    }).join(''));
                    const payload = JSON.parse(jsonPayload);
                    userId = payload.userId || payload.sub;
                    logMessage(`사용자 ID: ${userId}`, "info");
                } catch (e) {
                    logMessage('토큰에서 사용자 ID를 추출할 수 없습니다: ' + e, "warning");
                }
                
                subscriptions['notification'] = stompClient.subscribe('/user/queue/notification', handleNotification);
                subscriptions['unread'] = stompClient.subscribe('/user/queue/unread', updateUnreadCount);
                
                updatePresence('ONLINE');
                startHeartbeat();
            },
            function(error) {
                logMessage('연결 오류: ' + error, "error");
            }
        );
    }

    function disconnect() {
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        if (stompClient !== null) {
            updatePresence('OFFLINE');
            Object.values(subscriptions).forEach(sub => {
                try {
                    sub.unsubscribe();
                } catch (e) {}
            });
            subscriptions = {};
            
            stompClient.disconnect();
            logMessage('연결이 해제되었습니다', "info");
            stompClient = null;
            currentRoomId = null;
            updateRoomDisplay();
        }
    }

    function subscribe() {
        if (!stompClient) {
            logMessage("먼저 연결을 해주세요", "error");
            return;
        }
        
        if (currentRoomId) {
            unsubscribeRoom(currentRoomId);
        }
        
        currentRoomId = document.getElementById('roomId').value;
        
        logMessage(`채팅방 ${currentRoomId} 구독 중...`, "info");
        
        subscriptions[`room_${currentRoomId}`] = stompClient.subscribe(
            '/topic/chat.room.' + currentRoomId,
            handleIncomingMessage
        );

        subscriptions[`read_${currentRoomId}`] = stompClient.subscribe(
            '/topic/chat.room.' + currentRoomId + '.read',
            updateReadStatus
        );
        
        subscriptions[`typing_${currentRoomId}`] = stompClient.subscribe(
            '/topic/chat.room.' + currentRoomId + '.typing',
            handleTypingStatus
        );

        updatePresence('ONLINE', currentRoomId);
        markAsRead();
        fetchMessages();
        updateRoomDisplay();
        logMessage(`채팅방 ${currentRoomId} 구독 완료`, "success");
    }

    function unsubscribe() {
        if (!currentRoomId) {
            logMessage("현재 구독 중인 채팅방이 없습니다", "warning");
            return;
        }
        
        unsubscribeRoom(currentRoomId);
        updatePresence('ONLINE', null);
        currentRoomId = null;
        updateRoomDisplay();
        document.getElementById('messages').innerHTML = '';
        logMessage("채팅방에서 퇴장했습니다", "info");
    }

    function unsubscribeRoom(roomId) {
        ['room', 'read', 'typing'].forEach(type => {
            const subKey = `${type}_${roomId}`;
            if (subscriptions[subKey]) {
                try {
                    subscriptions[subKey].unsubscribe();
                    delete subscriptions[subKey];
                } catch (e) {
                    logMessage(`구독 해제 오류 (${type}): ${e}`, "error");
                }
            }
        });
    }

function sendMessage() {
    if (!stompClient || !currentRoomId) {
        logMessage("먼저 채팅방에 입장해주세요", "error");
        return;
    }
    
    const messageContent = document.getElementById('message').value;
    if (!messageContent) {
        logMessage("메시지를 입력해주세요", "error");
        return;
    }
    
    const chatMessage = {
        roomId: currentRoomId,
        content: messageContent,
        type: 'TEXT'
    };
    
    // 메시지 전송
    logMessage(`메시지 전송 중: ${JSON.stringify(chatMessage)}`, "info");
    stompClient.send('/app/chat.send', {}, JSON.stringify(chatMessage));
    
    // 임시 메시지를 화면에 즉시 추가
    const tempMessage = {
        id: 'temp-' + new Date().getTime(),
        roomId: currentRoomId,
        senderId: userId,
        content: messageContent,
        createdAt: new Date(),
        type: 'TEXT'
    };
    addMessageToDisplay(tempMessage);
    
    document.getElementById('message').value = '';
}



    function markAsRead() {
        if (!stompClient || !currentRoomId) {
            logMessage("채팅방에 입장한 상태에서만 읽음 처리가 가능합니다", "warning");
            return;
        }
        
        const readRequest = { roomId: currentRoomId };
        stompClient.send('/app/chat.read', {}, JSON.stringify(readRequest));
        logMessage(`채팅방 ${currentRoomId}의 메시지를 읽음 처리했습니다`, "info");
    }

    function fetchMessages() {
        if (!currentRoomId) {
            logMessage("먼저 채팅방을 선택해주세요", "warning");
            return;
        }
        
        const token = document.getElementById('token').value;
        if (!token) {
            logMessage("토큰을 입력해주세요", "error");
            return;
        }
        
        logMessage(`채팅방 ${currentRoomId}의 메시지를 조회합니다...`, "info");
        
        fetch(`${baseUrl}/api/chat/rooms/${currentRoomId}/messages?page=0&size=20`, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) throw new Error('메시지 조회 실패: ' + response.status);
            return response.json();
        })
        .then(data => {
            logMessage(`메시지 조회 성공: ${data.messages.length}개의 메시지`, "success");
            displayMessages(data);
            updateParticipantStatus(data);
        })
        .catch(error => logMessage('메시지 조회 오류: ' + error.message, "error"));
    }

    function fetchChatRooms() {
        const token = document.getElementById('token').value;
        if (!token) {
            logMessage("토큰을 입력해주세요", "error");
            return;
        }
        
        logMessage("채팅방 목록을 조회합니다...", "info");
        
        fetch(`${baseUrl}/api/chat/rooms?page=0&size=10`, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) throw new Error('채팅방 목록 조회 실패: ' + response.status);
            return response.json();
        })
        .then(data => {
            logMessage(`채팅방 목록 조회 성공: ${data.content.length}개의 채팅방`, "success");
            displayChatRooms(data);
        })
        .catch(error => logMessage('채팅방 목록 조회 오류: ' + error.message, "error"));
    }

function handleIncomingMessage(message) {
    let messageData;
    try {
        messageData = JSON.parse(message.body);
        
        // 메시지 타입이 없으면 기본적으로 채팅 메시지로 간주
        if (!messageData.type) {
            messageData.type = 'CHAT';
        }
        
        switch(messageData.type) {
            case 'TYPING_STATUS':
                handleTypingStatus(messageData.data);
                break;
            case 'CONTENT_FILTERED':
                logMessage(`메시지 ID ${messageData.messageId}가 필터링되었습니다: ${messageData.content}`, "warning");
                break;
            case 'CHAT':
                if (!messageData.senderId || !messageData.content) {
                    logMessage("유효하지 않은 메시지 형식", "error");
                    console.error("Invalid message format:", messageData);
                    return;
                }
                addMessageToDisplay(messageData);
                break;
            default:
                // READ_STATUS는 별도의 채널로 처리되므로 여기서는 무시
                console.log("Message received on main channel:", messageData);
        }
    } catch (e) {
        console.error("Error processing message:", e, message.body);
    }
}




    // 알림 처리
    function handleNotification(notification) {
        // 알림 타입에 따른 처리
        if (notification.type === 'NEW_MESSAGE') {
            // 새 메시지 알림
            logMessage(`새 메시지 알림: 채팅방 ${notification.roomId}에 새 메시지가 있습니다`, "info");
        } else if (notification.type === 'ROOM_STATUS') {
            // 채팅방 상태 변경 알림
            logMessage(`채팅방 상태 변경: 채팅방 ${notification.roomId}의 상태가 ${notification.status}로 변경되었습니다`, "info");
        }
    }
    
function updatePresence(status, activeRoomId = currentRoomId) {
    if (stompClient && stompClient.connected) {
        stompClient.send('/app/presence', {},
            JSON.stringify({
                status: status,
                activeRoomId: activeRoomId
            })
        );
        logMessage(`사용자 상태가 ${status}로 변경되었습니다.`, "info");
    }
}

    

function updateUnreadCount(message) {
    const unreadData = JSON.parse(message.body);
    const roomId = unreadData.roomId;
    const count = unreadData.unreadCount;
    
    if (roomId === currentRoomId) {
        document.getElementById('unreadCount').textContent = count;
    }
    
    logMessage(`채팅방 ${roomId}의 읽지 않은 메시지: ${count}개`, "info");
}

function updateReadStatus(message) {
    try {
        const readData = JSON.parse(message.body);
        console.log("Read status received:", readData);
        
        // 읽음 상태 UI 업데이트
        const messageElements = document.querySelectorAll('.message-container');
        messageElements.forEach(element => {
            const readStatusElement = element.querySelector('.read-status');
            if (readStatusElement) {
                readStatusElement.textContent = '읽음';
            }
        });
        
        // 읽지 않은 메시지 카운트 리셋
        if (readData.roomId === currentRoomId) {
            document.getElementById('unreadCount').textContent = '0';
        }
        
        logMessage(`사용자 ${readData.userId}가 채팅방 ${readData.roomId}의 메시지를 읽었습니다`, "info");
    } catch (e) {
        console.error("Error processing read status:", e, message.body);
    }
}





// 메시지 화면에 표시
function displayMessages(data) {
    const messagesDiv = document.getElementById('messages');
    messagesDiv.innerHTML = '';
    
    // 메시지 역순으로 정렬 (최신 메시지가 아래에 표시)
    const sortedMessages = data.messages.sort((a, b) =>
        new Date(a.createdAt) - new Date(b.createdAt)
    );
    
    sortedMessages.forEach(message => {
        addMessageToDisplay(message);
    });
    
    // 스크롤을 맨 아래로 이동
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// 타이핑 상태 처리 함수
function handleTypingStatus(typingData) {
    // 자신의 타이핑 상태는 무시
    if (typingData.userId == userId) return;
    
    const typingIndicator = document.getElementById('typingIndicator');
    
    // 데이터가 중첩되어 있는 경우 처리
    const userData = typingData.data || typingData;
    
    if (userData.typing) {
        // 타이핑 중 표시
        typingIndicator.textContent = `사용자 ${userData.userId}가 입력 중...`;
        typingIndicator.style.display = 'block';
    } else {
        // 타이핑 종료 표시
        typingIndicator.style.display = 'none';
    }
}



// 타이핑 상태 전송 함수
function sendTypingStatus(isTyping) {
    if (!stompClient || !currentRoomId) return;
    
    const typingRequest = {
        roomId: currentRoomId,
        isTyping: isTyping
    };
    
    stompClient.send('/app/chat.typing', {}, JSON.stringify(typingRequest));
}

function addMessageToDisplay(message) {
    // 유효하지 않은 메시지 무시
    if (!message || !message.senderId || !message.content) {
        logMessage("유효하지 않은 메시지 형식", "error");
        return;
    }
    
    const messagesDiv = document.getElementById('messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message-container';
    
    // 메시지 발신자가 현재 사용자인지 확인
    const isMine = message.senderId == userId;
    if (isMine) {
        messageDiv.style.backgroundColor = '#e6f7ff';
        messageDiv.style.marginLeft = '20%';
    }
    
    const senderDiv = document.createElement('div');
    senderDiv.className = 'message-sender';
    senderDiv.textContent = isMine ? '나' : `사용자 ${message.senderId} (${message.senderRole || '알 수 없음'})`;
    
    const timeDiv = document.createElement('div');
    timeDiv.className = 'message-time';
    try {
        const messageTime = new Date(message.createdAt);
        timeDiv.textContent = messageTime.toLocaleString();
    } catch (e) {
        timeDiv.textContent = '시간 정보 없음';
    }
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    contentDiv.textContent = message.content;
    
    const readStatusDiv = document.createElement('div');
    readStatusDiv.className = 'read-status';
    readStatusDiv.textContent = '읽지 않음';  // 기본값
    
    messageDiv.appendChild(senderDiv);
    messageDiv.appendChild(timeDiv);
    messageDiv.appendChild(contentDiv);
    messageDiv.appendChild(readStatusDiv);
    
    messagesDiv.appendChild(messageDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// 채팅방 목록 표시
function displayChatRooms(data) {
    const logDiv = document.getElementById('log');
    
    // 채팅방 목록 헤더 추가
    const header = document.createElement('p');
    header.style.fontWeight = 'bold';
    header.textContent = '=== 채팅방 목록 ===';
    logDiv.appendChild(header);
    
    // 각 채팅방 정보 추가
    data.content.forEach(room => {
        const roomInfo = document.createElement('p');
        roomInfo.innerHTML = `채팅방 ID: ${room.id} | 마지막 메시지: ${room.lastMessageTime || '없음'} | 읽지 않은 메시지: ${room.unreadCount || 0}`;
        logDiv.appendChild(roomInfo);
        
        // 채팅방 입장 버튼 추가
        const enterButton = document.createElement('button');
        enterButton.textContent = '입장';
        enterButton.style.marginLeft = '10px';
        enterButton.onclick = function() {
            document.getElementById('roomId').value = room.id;
            subscribe();
        };
        roomInfo.appendChild(enterButton);
    });
    
    logDiv.scrollTop = logDiv.scrollHeight;
}

function startHeartbeat() {
    if (heartbeatInterval) clearInterval(heartbeatInterval);
    
    heartbeatInterval = setInterval(() => {
        if (stompClient && stompClient.connected) {
            stompClient.send('/app/presence', {},
                JSON.stringify({
                    status: 'ONLINE',
                    activeRoomId: currentRoomId,
                    timestamp: new Date().getTime()
                })
            );
        }
    }, 30000);
}


// 참가자 상태 업데이트
function updateParticipantStatus(data) {
    const participantsList = document.getElementById('participantStatus');
    participantsList.innerHTML = '';
    
    if (data.listener) {
        const listenerItem = document.createElement('li');
        const statusSpan = document.createElement('span');
        statusSpan.className = 'online-status ' + (data.listener.online ? 'online' : 'offline');
        listenerItem.appendChild(statusSpan);
        listenerItem.appendChild(document.createTextNode(
            `리스너 (ID: ${data.listener.userId}): ${data.listener.online ? '온라인' : '오프라인'}`
        ));
        participantsList.appendChild(listenerItem);
    }
    
    if (data.speaker) {
        const speakerItem = document.createElement('li');
        const statusSpan = document.createElement('span');
        statusSpan.className = 'online-status ' + (data.speaker.online ? 'online' : 'offline');
        speakerItem.appendChild(statusSpan);
        speakerItem.appendChild(document.createTextNode(
            `스피커 (ID: ${data.speaker.userId}): ${data.speaker.online ? '온라인' : '오프라인'}`
        ));
        participantsList.appendChild(speakerItem);
    }
}

// 현재 채팅방 표시 업데이트
function updateRoomDisplay() {
    document.getElementById('currentRoomDisplay').textContent =
        currentRoomId ? currentRoomId : '없음';
}

// 로그 메시지 표시
function logMessage(message, type) {
    const logDiv = document.getElementById('log');
    const p = document.createElement('p');
    p.style.margin = '5px 0';
    p.className = type || '';
    
    // 타임스탬프 추가
    const now = new Date();
    const timestamp = `${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
    
    p.textContent = `[${timestamp}] ${message}`;
    logDiv.appendChild(p);
    logDiv.scrollTop = logDiv.scrollHeight;
}

    // 페이지 로드 후 메시지 입력 필드에 이벤트 리스너 추가
document.addEventListener('DOMContentLoaded', function() {
    const messageInput = document.getElementById('message');
    
    messageInput.addEventListener('input', function() {
        // 타이핑 시작 이벤트 전송
        if (!typingTimeout) {
            sendTypingStatus(true);
        }
        
        // 타이핑 종료 타이머 설정 (2초 후 타이핑 종료)
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            sendTypingStatus(false);
            typingTimeout = null;
        }, 2000);
    });
});
    
    // HTML 파일에 추가
window.addEventListener('beforeunload', function(e) {
    if (stompClient && stompClient.connected) {
        stompClient.send('/app/presence', {},
            JSON.stringify({status: 'OFFLINE', activeRoomId: null})
        );
    }
});


// 페이지 가시성 변경 감지
document.addEventListener('visibilitychange', function() {
    const status = document.hidden ? 'AWAY' : 'ONLINE';
    updatePresence(status);
    if (status === 'ONLINE' && currentRoomId) {
        markAsRead();
    }
});

window.addEventListener('focus', function() {
    updatePresence('ONLINE');
});

window.addEventListener('blur', function() {
    updatePresence('AWAY');
});

<!--window.addEventListener('focus', function() {-->
<!--    if (stompClient && stompClient.connected) {-->
<!--        stompClient.send('/app/presence', {},-->
<!--            JSON.stringify({status: 'ONLINE', activeRoomId: currentRoomId})-->
<!--        );-->
<!--        logMessage("사용자 상태가 ONLINE으로 변경되었습니다.", "info");-->
<!--    }-->
<!--});-->

<!--window.addEventListener('blur', function() {-->
<!--    if (stompClient && stompClient.connected) {-->
<!--        stompClient.send('/app/presence', {},-->
<!--            JSON.stringify({status: 'AWAY', activeRoomId: currentRoomId})-->
<!--        );-->
<!--        logMessage("사용자 상태가 AWAY로 변경되었습니다.", "info");-->
<!--    }-->
<!--});-->

</script> </body> </html> ```

